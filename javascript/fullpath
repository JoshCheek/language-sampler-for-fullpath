#!/usr/bin/env node
"use strict";

const spawn         = require('child_process').spawn;
const args          = process.argv.slice(2);
const cwd           = process.cwd();
const stdout        = process.stdout;
let   relativePaths = removeFlags(args);
const doHelp        = hasFlag(args, "-h") || hasFlag(args, "--help");
const doCopy        = hasFlag(args, "-c") || hasFlag(args, "--copy");
const newlineAscii  = 10;

function chomp(str) {
  if (str.length == 0) return str;
  if (str[str.length-1] != newlineAscii)
    return str;
  return String.prototype.substring.call(str, 0, str.length-1);
}

function printPaths(stream, cwd, relativePaths) {
  const absolutePaths = relativePaths
          .filter(function(arg) { return arg != "" })
          .map(function(arg) { return [cwd, chomp(arg)].join("/") });
  if(absolutePaths.length == 1)
    stream.write(absolutePaths[0]);
  else
    absolutePaths.forEach(function(path) { stream.write(path+"\n") });
}

function removeFlags(array) {
  return array.filter(function(string) {
    return string[0] != "-"[0];
  });
}

function hasFlag(strings, flag) {
  return -1 != strings.indexOf(flag);
}

function copyPaths(cwd, relativePaths) {
  const pbcopy = spawn("pbcopy", [], {stdio: ["pipe", "ignore", "inherit"]});
  printPaths(pbcopy.stdin, cwd, relativePaths);
  pbcopy.stdin.end();
}

if(doHelp) {
  stdout.write("usage: fullpath *[relative-paths] [-c]\n");
  stdout.write("\n");
  stdout.write("  Prints the fullpath of the paths\n");
  stdout.write("  If no paths are given as args, it will read them from stdin\n");
  stdout.write("\n");
  stdout.write("  If there is only one path, the trailing newline is omitted\n");
  stdout.write("\n");
  stdout.write("  The -c flag will copy the results into your pasteboard\n");
} else if(relativePaths.length == 0) {
  let stdinData = "";
  process.stdin.on('data', function(data) { stdinData += data; });
  process.stdin.on('close', function() {
    relativePaths = stdinData.split("\n");
    printPaths(stdout, cwd, relativePaths);
    doCopy && copyPaths(cwd, relativePaths);
  });
} else {
  printPaths(stdout, cwd, relativePaths);
  doCopy && copyPaths(cwd, relativePaths);
}
