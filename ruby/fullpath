#!/usr/bin/env ruby

def self.parse(argv)
  args = argv.dup
  { help_screen: <<-HELP_SCREEN.gsub(/^      /, ''),
      usage: fullpath *[relative-paths] [-c]

        Prints the fullpath of the paths
        If no paths are given as args, it will read them from stdin

        If there is only one path, the trailing newline is omitted

        The -c flag will copy the results into your pasteboard
    HELP_SCREEN
    print_help:     !!(args.delete("-h")||args.delete("--help")),
    copy_result:    !!(args.delete("-c")||args.delete("--copy")),
    relative_paths: args,
  }
end

def self.run(invocation)
  stream = invocation[:stream]
  invocation[:relative_paths]
    .lazy
    .map(&:chomp)
    .reject(&:empty?)
    .map { |path| File.expand_path path }
    .each_with_index { |path, index|
      stream << "\n" if 1 == index
      stream << path
      stream << "\n" if 1 <= index
    }
end

class MultiStream
  def initialize(*streams)
    @streams = streams
  end
  def <<(str)
    @streams.each { |stream| stream << str }
    self
  end
end

invocation = parse(ARGV)

if invocation[:print_help]
  puts invocation[:help_screen]
  exit
end

if invocation[:relative_paths].none?
  invocation[:relative_paths] = $stdin.each_line
end

invocation[:stream] = $stdout

if invocation[:copy_result]
  require 'open3'
  Open3.popen3("pbcopy") do |stream, *|
    invocation[:stream] = MultiStream.new(invocation[:stream], stream)
    run invocation
  end
else
  run invocation
end
